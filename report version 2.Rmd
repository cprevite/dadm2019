--- 
title: 'Report: Text mining'
author: "Claudio Previte and Ana -Maria Casian"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output: 
  html_document:
    toc: TRUE
    toc_float:
      collapsed: true
      smooth_scroll: true
---



```{r message=FALSE, warning=FALSE}
library(here)
library(Hmisc)
library(dplyr)
library(DataExplorer)
library(ggplot2)
library(lattice)
library(inspectdf)
library(kableExtra)
library(explore)
library(DT)
library(dplyr)
library(Boruta)
library(corrr)
library(tidyverse)

```



# Executive summary

## Challenges

## Analysis

## Results

# General

## Source of data

## Case description

# Data processing


## Loading data

```{r}
bands <- read.csv2(file = here('bands3.csv'), sep = ';',na.strings = "?")
```


## Data visualisation

```{r}
str(bands)
```


### First data transformation to continue looking at the vars

```{r }


#change class to numeric for numeric variables 
cols_numeric = c(21:39)  
bands[,cols_numeric] = apply(bands[,cols_numeric], 2, function(x) as.numeric(as.character(x))) 

# uppercase for all the factor values
bands <- as.data.frame(lapply(bands,function(x) 
  if(is.factor(x)) factor(toupper(x)) 
  else(x)))


```




```{r}
datatable(bands)

bands %>% 
  introduce() %>%
  t()%>%
  kable() %>%
  kable_styling(bootstrap_options = c("striped", "hover","condensed","bordered"),full_width = F, position = "center")%>%
  footnote(symbol = strwrap("Sort description of the data"))


plot_intro(bands)

summary(bands)

bands %>% 
  explore::describe() %>%
  kable() %>%
  kable_styling(bootstrap_options = c("striped", "hover","condensed","bordered"),full_width = F, position = "center")

show_plot(inspect_na(bands), col_palette=2)

```


### Check the data structure

```{r, message=FALSE, warning=FALSE, include= FALSE}
str(bands) #this part will not apear in the report, but we should comment about it. This line of code helped us to decide wich data to transform in the first part

```

### Check the structure of the missing values

In this part we use the'aggr' function Calculate or plot the amount of missing/imputed values in each variable and the amount of missing/imputed values in certain combinations of variables.
```{r}

library(VIM)
aggr(bands[, which(sapply(bands, function(x)all(any(is.na(x)))) == TRUE)], sortVar=TRUE, cex.lab=0.8, cex.axis=0.9,  numbers = TRUE, combined = TRUE,  oma = c(8,1,1,1))


```

```{r}
missing.values <- bands %>%
  gather(key = "key", value = "val") %>%
  mutate(isna = is.na(val)) %>%
  group_by(key) %>%
  mutate(total = n()) %>%
  group_by(key, total, isna) %>%
  summarise(num.isna = n()) %>%
  mutate(pct = num.isna / total * 100)


levels <-
    (missing.values  %>% filter(isna == T) %>% arrange(desc(pct)))$key

percentage.plot <- missing.values %>%
      ggplot() +
        geom_bar(aes(x = reorder(key, desc(pct)), 
                     y = pct, fill=isna), 
                 stat = 'identity', alpha=0.8) +
      scale_x_discrete(limits = levels) +
      scale_fill_manual(name = "", 
                        values = c('steelblue', 'tomato3'), labels = c("Present", "Missing")) +
      coord_flip() +
      labs(title = "Percentage of missing values", x =
             'Variable', y = "% of missing values")

percentage.plot
```


```{r}


row.plot <- bands %>%
  mutate(id = row_number()) %>%
  gather(-id, key = "key", value = "val") %>%
  mutate(isna = is.na(val)) %>%
  ggplot(aes(key, id, fill = isna)) +
    geom_raster(alpha=0.8) +
    scale_fill_manual(name = "",
        values = c('steelblue', 'tomato3'),
        labels = c("Present", "Missing")) +
    labs(x = "Variable",
           y = "Row Number", title = "Missing values in rows") +
    coord_flip()

row.plot
```

EDA
```{r}
bands %>%
  introduce() %>%
  t() %>%
  kable() %>%
  kable_styling(
    bootstrap_options = c("striped", "hover", "condensed", "bordered"),
    full_width = F,
    position = "center"
  ) %>%
  footnote(symbol = strwrap("Short description of the data"))


plot_intro(bands)

bands %>% explore_all(target = band_type)
```


```{r}
#Delete the last rows that have consecutive missing data
bands <- bands[-c(486:540),]

# replace missing values of "location variable" with value "Undefined"
bands$location = as.character(bands$location)
bands$location[is.na(bands$location)] <- "UNDEFINED"
bands$location = as.factor(bands$location)

# Delete variables that are not needed
bands <-
  bands[, which(
    !names(bands) %in% c(
      "date",
      "ink_color",
      "customer", 
      'cylinder_division'
      
    )
  )]
```

```{r}
# replace missing values with knn 
# we have to decide if we want to reÃ¨lace only factor or all variables with this method...
library(DMwR)

bands <- knnImputation(bands, k=10)

# check missing value
anyNA(bands)
```




```{r}


boruta_test <- Boruta(band_type ~ ., data = bands, doTrace = 2)
table_result <- as.data.frame(boruta_test$finalDecision)
setDT(table_result, keep.rownames = TRUE)[]
colnames(table_result) <- c("Variable", "Decision")

kable(table_result) %>%
  kable_styling(
    bootstrap_options = c("striped", "hover", "condensed", "bordered"),
    full_width = F,
    position = "center"
  ) %>%
  footnote(symbol = strwrap("Results of the boruta test")) %>%
  scroll_box(width = "500px", height = "300px")


plot(boruta_test, xlab = "", xaxt = "n")
lz <- lapply(1:ncol(boruta_test$ImpHistory), function(i)
  boruta_test$ImpHistory[is.finite(boruta_test$ImpHistory[, i]), i])
names(lz) <- colnames(boruta_test$ImpHistory)
Labels <- sort(sapply(lz, median))
axis(
  side = 1,
  las = 2,
  labels = names(Labels),
  at = 1:ncol(boruta_test$ImpHistory),
  cex.axis = 0.8
)


variables_to_keep <- table_result %>%
  filter(table_result$Decision == 'Confirmed' |
           table_result$Decision == 'Tentative')

band_typeVar <- data.frame('band_type', 'Confirmed')
names(band_typeVar) <- c('Variable', 'Decision')

variables_to_keep <- rbind(variables_to_keep, band_typeVar)

names_variables_to_keep <- variables_to_keep$Variable

names_variables_to_keep

```


# Deleting useless variables


```{r}

bands <-
  bands[, which(
    names(bands) %in% names_variables_to_keep
  )]

```



# Outliers. We have generated the boxplot and the summary for all the variables and examinated the outliers. Given that the outliers were not showing any significant values, we have decided that there are no error meassurements and neither error entries in the data

```{r, message=FALSE, warning=FALSE, include= FALSE}

numeric_column <- names(select_if(bands, is.numeric))

for (i in numeric_column) {
  print(summary(bands[i]))
  print (boxplot(bands[i])$out)
}

```



```{r fig.height= 12}


plot_histogram(bands)

plot_density(bands)



plot_boxplot(bands, by= 'band_type',  ncol = 2, title = "Side-by-side boxplots")

plot_correlation(bands, type= 'c', cor_args = list( 'use' = 'complete.obs'))


numeric_column <- names(select_if(bands, is.numeric))
bands %>% 
  select(numeric_column, band_type) %>%
  explore_all(target = band_type)

#ggpairs(bands[,-40], ggplot2::aes(colour=band_type))

# split data in 2
bands.band <- filter(bands, bands$band_type == 'BAND')

bands.noband <- filter(bands, bands$band_type == 'NOBAND')

# summary(bands.band)
# summary(bands.noband)




```









## MODELS

```{r}
#normalize data
# doesn't change the results so we will not keep the modifications
b.process <- preProcess(bands, method= 'range')
b <- predict(b.process, newdata = bands)
```


# test and train sets
```{r}

library(caret)

# Create the training and test datasets
set.seed(100)

# Step 1: Get row numbers for the training data
trainRowNumbers <- createDataPartition(b$band_type, p=0.75, list=FALSE)

# Step 2: Create the training  dataset
trainData <- b[trainRowNumbers,]

# Step 3: Create the test dataset
testData <- b[-trainRowNumbers,]
```



```{r}
# MARS Multivariate Adaptive Regression Splines
# recursive feature elimination (RFE)
set.seed(100)
options(warn = -1)

subsets <- c(1:6, 10, 15, 35)

ctrl <- rfeControl(
  functions = rfFuncs,
  method = "repeatedcv",
  repeats = 5,
  verbose = FALSE
)
trainData <- trainData[, -1]

lmProfile <- rfe(
  x = trainData,
  y = trainData$band_type,
  sizes = subsets,
  rfeControl = ctrl
)

lmProfile


# Set the seed for reproducibility
set.seed(100)

# Train the model using randomForest and predict on the training data itself.
model_mars = train(band_type ~ ., data = trainData, method = 'earth')
fitted <- predict(model_mars)
varimp_mars <- varImp(model_mars)
plot(varimp_mars, main = "Variable Importance with MARS")


model_mars

predicted <- predict(model_mars, testData)
predicted

confusionMatrix(
  reference = testData$band_type,
  data = predicted,
  mode = 'everything',
  positive = 'NOBAND'
)
```

```{r}
# random forest

library(randomForest)
library(funModeling)
# Call the function:
# delete cylinder_no because too much levels for the model
integ_mod_1 <- data_integrity_model(data = b[,-1], model_name = "randomForest")
integ_mod_1$data_ok


# Any errors ?
integ_mod_1

model_rf <- randomForest(formula(band_type ~.), 
                          data= trainData, 
                          ntree=500, mtry=4, 
                          importance=TRUE, 
                          localImp=TRUE,
                          na.action=na.roughfix,
                          replace=FALSE)
print(model_rf)

head(round(importance(model_rf), 2))
varImpPlot(model_rf)

library(gmodels)

rf.pred<-predict(model_rf, testData, type="class")
rf.pred

table(true=testData$band_type, pred = rf.pred)

CrossTable(x=testData$band_type, y=rf.pred, prop.chisq=FALSE)

confusionMatrix(rf.pred, testData$band_type, positive = 'NOBAND')
```


```{r}
# logistic regression

fitControl <- trainControl(method = "none")

model_lr <-
  train(band_type ~ .,
        data = trainData,
        method = "glm",
        trControl = fitControl)

print(model_lr$finalModel)

pred <- predict(model_lr, newdata = testData)

print(table(pred))

mat <-
  confusionMatrix(data = pred,
                  reference = testData$band_type,
                  positive = "NOBAND")
print(mat)
```

```{r}
# SVM1

fitControl <- trainControl(method = "cv", number = 5)

model_svm <- train(
  band_type ~ .,
  data =
    trainData,
  method = "svmLinear",
  trControl = fitControl,
  tuneGrid = data.frame(C = 10)
)
print(model_svm)

print(confusionMatrix(
  data = predict(model_svm, newdata =
                   testData),
  reference = testData$band_type,
  positive = "NOBAND"
))




```

```{r}
#SVM2


model_svm2 <- train(band_type ~ .,
                          data = trainData, 
                          method = "svmRadialCost",
                          preProcess = "range",
                          trace = FALSE,
                          trControl = trainControl(method = "repeatedcv", number = 10, repeats = 10, 
                                                  verboseIter = FALSE))
model_svm2

plot(model_svm2)

C <- c(0.25, 0.1, 0.5, 1, 10, 100)
sigma <- c(0.0001, 0.001, 0.01, 0.1, 1)
gr.radial<-expand.grid(C = C, sigma = sigma)

model_svm3<- train(band_type ~ .,
                          data = trainData,
                          method = "svmRadial",
                          preProcess = "range",
                          trace=FALSE,
                          trControl = trainControl(method = "repeatedcv", number = 10, repeats = 10, 
                                                  verboseIter = FALSE),
                          tuneGrid=gr.radial)
model_svm3

plot(model_svm3)

print(confusionMatrix(
  data = predict(model_svm3, newdata =
                   testData),
  reference = testData$band_type,
  positive = "NOBAND"
))
```


```{r neural network model}

numFolds <-
  trainControl(
    method = 'cv',
    number = 10,
    classProbs = TRUE,
    verboseIter = TRUE,
    summaryFunction = twoClassSummary,
    preProcOptions = list(
      thresh = 0.75,
      ICAcomp = 3,
      k = 5
    )
  )
fit2 <-
  train(
    band_type ~ . - band_type,
    data = trainData,
    method = 'nnet',
    preProcess = c('center', 'scale'),
    trControl = numFolds,
    tuneGrid = expand.grid(size = c(10), decay = c(0.1))
  )

results1 <- predict(fit2, newdata = testData)
conf1 <-
  confusionMatrix(results1, testData$band_type, positive = 'NOBAND')
conf1

probs <- predict(fit2, newdata = testData, type = 'prob')
probs


```










```{r bands.ct}
require(rpart)
library(rpart.plot)
set.seed(123456)
bands.ct <-
  rpart(
    band_type ~ .,
    method = "class",
    data = bands,
    control = rpart.control(minsplit = 4,
                            cp = 1e-05),
    model = TRUE
  )

summary(bands.ct)

rpart.plot(bands.ct, box.palette = "RdBu", nn = FALSE)

# par(mar = c(0.5, 1, 0.5, 1))
# plot(bands.ct, uniform = TRUE)
# text(bands.ct, use.n = TRUE, all = TRUE, cex = 0.6)


```


```{r bands.par}


require(lattice)

trellis.par.set(col.whitebg())
plot.bands.par <-
  xyplot(
    roller_durometer ~ viscosity,
    bands,
    groups = band_type,
    pch = 16,
    col = c("red", "green"),
    panel = function(x, y, groups, ...) {
      panel.superpose(x, y, groups, ...)
      panel.abline(v = 2.45, lty = 2)
      panel.segments(2.45, 1.75, max(x) * 2, 1.75, lty = 2)
      panel.segments(4.95, min(y) * -2, 4.95, 1.75, lty = 2)
      panel.segments(2.45, 1.65, 4.95, 1.65, lty = 2)
      panel.segments(4.95, 1.55, max(x) * 2, 1.55, lty = 2)
    },
    key = list(
      columns = 3,
      col = c("red", "green"),
      text = list(c("BAND",
                    "NOBAND"))
    )
  )
print(plot.bands.par)

printcp(bands.ct)

par(pty = "s")
plotcp(bands.ct)

# pruning trees
par(pty = "s")
with(
  bands.ct,
  plot(
    cptable[, 3],
    xlab = "Tree Number",
    ylab = "Resubstitution Error (R)",
    type = "b"
  )
)

par(pty = "s")
with(
  bands.ct,
  plot(
    cptable[, 4],
    xlab = "Tree Number",
    ylab = "Cross-Validated Error (R(cv))",
    type = "b"
  )
)

par(pty = "s")
plotcp(bands.ct)
with(bands.ct, {
  lines(cptable[, 2] + 1, cptable[, 3], type = "b", col = "red")
  legend(
    3,
    1,
    c("Resub. Error", "CV Error", "min(CV Error)+1SE"),
    lty = c(1,
            1, 2),
    col = c("red", "black", "black"),
    bty = "n"
  )
})

bands.prune <- prune(bands.ct, cp = 0.1)
summary(bands.prune)

library(knitr)
bands.pred <- predict(bands.prune, type = "class")
table(bands.pred, bands$band_type)
```



